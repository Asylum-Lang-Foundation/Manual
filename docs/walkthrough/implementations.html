<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Structs &amp; Implementations &mdash; Asylum  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Inheritance" href="inheritance.html" />
    <link rel="prev" title="&lt;no title&gt;" href="errors.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #de7cff" >

          
          
          <a href="../index.html" class="icon icon-home">
            Asylum
              <img src="../_static/AsylumLogo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Asylum Language Reference:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about.html">About Asylum</a></li>
<li class="toctree-l1"><a class="reference internal" href="helloWorld.html">First Program (Hello World)</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataTypes.html">Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuples.html">Tuples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Structs &amp; Implementations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#constructors">Constructors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#better-contructors">Better Contructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#member-initialization">Member Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-constructors">Copy Constructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#custom-copy-constructor">Custom Copy Constructor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#move-constructors">Move Constructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#custom-move-constructor">Custom Move Constructor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#empty-constructor">Empty Constructor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#default-values">Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#destructors">Destructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#attributes">Attributes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#attribute-list">Attribute List</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#properties">Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operators">Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overloadable-operators">Overloadable Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dereference-operator-overloading">Dereference Operator Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#false-operator-special-notes">False Operator Special Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#casts">Casts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#challenges">Challenges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#challenge-solutions">Challenge Solutions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="inheritance.html">Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="controlFlow.html">Control Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="enums.html">Enums</a></li>
<li class="toctree-l1"><a class="reference internal" href="strings.html">Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameterTypes.html">Parameter Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="pointers.html">Pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="allocators.html">Allocators</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/about.html">Asylum Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/antlr.html">AST Creation With ANTLR4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/builder.html">Program Builder API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/visitor.html">Builder Code Calling For ASTs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/codeRepresentation.html">Working With The Code Representation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #de7cff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Asylum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Structs &amp; Implementations</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/walkthrough/implementations.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="structs-implementations">
<h1>Structs &amp; Implementations<a class="headerlink" href="#structs-implementations" title="Link to this heading"></a></h1>
<p>On the previous page, you learned how structs can give you custom data types that allow you to hold data. But we are also allowed to give them functions as well inside of implementation blocks:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">byte</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="n">byte</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">    </span><span class="n">byte</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">toHex</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">string</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&quot;#&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="s">&quot;x2&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="s">&quot;x2&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="s">&quot;x2&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the code above, we define a function for every single <code class="docutils literal notranslate"><span class="pre">Color</span></code> struct. We could then use it like such:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A struct can have as many implementation blocks as it desires.</p>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">r</span>: <span class="mh">0x21</span><span class="p">,</span>
<span class="w">        </span><span class="n">g</span>: <span class="mh">0x43</span><span class="p">,</span>
<span class="w">        </span><span class="n">b</span>: <span class="mh">0x75</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">toHex</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#214375</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More experience programmers are probably wondering why we are “copying” the newly created struct rather than moving it.</p>
<p>When a struct is newly constructed and assigned to a variable, it is “constructed in-place”. The reason a C++ syntax was not chosen is because it is not intuitive for beginners, and makes constructors messy if certain things that must be constructed depend on code in the constructor.</p>
<p>This property in Asylum will be discussed more in the section about move semantics.</p>
</div>
<section id="constructors">
<h2>Constructors<a class="headerlink" href="#constructors" title="Link to this heading"></a></h2>
<p>As you probably have noticed, it is a bit tedius to construct instances of structs. Defining a constructor allows you to make this process easier:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">byte</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x7F</span><span class="p">,</span><span class="w"> </span><span class="mh">0x84</span><span class="p">,</span><span class="w"> </span><span class="mh">0x29</span><span class="p">);</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">toHex</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#7f8429</span>
</pre></div>
</div>
<p>A lot is happening here, but let’s take this one step at a time.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">This</span></code> is a type only available in implementation blocks and resolves to the type being implemented. In this case, <code class="docutils literal notranslate"><span class="pre">This</span></code> resolves into <code class="docutils literal notranslate"><span class="pre">Color</span></code>.</p></li>
<li><p>In the constructor definition, the parameters <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> shadow the members in the <code class="docutils literal notranslate"><span class="pre">Color</span></code> struct and are inaccessible. We are able to get around this by using the <code class="docutils literal notranslate"><span class="pre">this.</span></code> prefix to access them from the current <code class="docutils literal notranslate"><span class="pre">Color</span></code> instance.</p></li>
<li><p>A constructor does not have the <code class="docutils literal notranslate"><span class="pre">fn</span></code> keyword in front and will never had a return type.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since a constructor is defined, you can no longer do the following:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">r</span>: <span class="mh">0x21</span><span class="p">,</span>
<span class="w">    </span><span class="n">g</span>: <span class="mh">0x43</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span>: <span class="mh">0x75</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The reason for this is that the default (empty) constructor will get “deleted”, as it assumes you don’t want your data to be constructed another way! However, assume <code class="docutils literal notranslate"><span class="pre">Color</span></code> now has a new variable described as <code class="docutils literal notranslate"><span class="pre">byte</span> <span class="pre">a</span></code> under <code class="docutils literal notranslate"><span class="pre">b</span></code>. The following is legal:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x7F</span><span class="p">,</span><span class="w"> </span><span class="mh">0x84</span><span class="p">,</span><span class="w"> </span><span class="mh">0x29</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g</span>: <span class="mh">0x53</span><span class="p">,</span>
<span class="w">    </span><span class="n">a</span>: <span class="mh">0x32</span>
<span class="p">};</span>
</pre></div>
</div>
<p>You’re still allowed to change values of members after the constructor is called!</p>
</div>
<section id="better-contructors">
<h3>Better Contructors<a class="headerlink" href="#better-contructors" title="Link to this heading"></a></h3>
<p>While the above approach works, it is very tedious. Luckily, there is a shortcut:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">byte</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span>: <span class="nc">r</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Overall, this is much shorter and cleaner. The following is happening:</p>
<ul class="simple">
<li><p>We signify we are constructing a member by calling the member like a function. For example, we are constructing <code class="docutils literal notranslate"><span class="pre">g</span></code> in the <code class="docutils literal notranslate"><span class="pre">Color</span></code> struct and are passing it a parameter with the name <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p></li>
<li><p>We are doing the same things with the <code class="docutils literal notranslate"><span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> members too, the only different is the <code class="docutils literal notranslate"><span class="pre">_</span></code>. The <code class="docutils literal notranslate"><span class="pre">_</span></code> symbol gets automatically replaced with the name of the member being intialized. By giving our parameters the same names as the members, we can reduce refactoring needed if things in the struct change.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The following does not work:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">byte</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span>: <span class="nc">r</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The reasons why are:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">_</span></code> in <code class="docutils literal notranslate"><span class="pre">r(_)</span></code> will try and use the parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>, but it does not exist.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">_</span></code> symbol does not work for member names to initialize, so <code class="docutils literal notranslate"><span class="pre">_(g)</span></code> does not know which member to initialize.</p></li>
</ul>
</section>
<section id="member-initialization">
<h3>Member Initialization<a class="headerlink" href="#member-initialization" title="Link to this heading"></a></h3>
<p>Suppose we have a struct with the following constructor:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span>: <span class="nc">name</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">num</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also have the following struct:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">Data</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data2</span><span class="p">;</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data3</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">data1</span></code>, <code class="docutils literal notranslate"><span class="pre">data2</span></code>, and <code class="docutils literal notranslate"><span class="pre">data3</span></code> variables must also be initialized. We can do this using the same technique from earlier:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num2</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num3</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span>: <span class="nc">data1</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">num1</span><span class="p">),</span><span class="w"> </span><span class="n">data2</span><span class="p">(</span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">num2</span><span class="p">),</span><span class="w"> </span><span class="n">data3</span><span class="p">(</span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">num3</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, what if these members require being initialized by data from another member? The rule of thumb is that you can not use a struct’s member variable until it is initialized, or else the compiler will error. We can get around this by the following:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span>: <span class="nc">data1</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">num1</span><span class="p">),</span><span class="w"> </span><span class="n">data2</span><span class="p">(</span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">data1</span><span class="p">.</span><span class="n">hash</span><span class="p">()),</span><span class="w"> </span><span class="n">data3</span><span class="p">(</span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">data2</span><span class="p">.</span><span class="n">hash</span><span class="p">())</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, if more complex operations need to be done in advance, you can fall back to a typical constructor as long as everything gets constructed:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span>: <span class="nc">data1</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="n">num1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">int</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data1</span><span class="p">.</span><span class="n">hash</span><span class="p">();</span>
<span class="w">        </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span><span class="p">(</span><span class="n">name2</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">);</span>
<span class="w">        </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data2</span><span class="p">.</span><span class="n">hash</span><span class="p">();</span>
<span class="w">        </span><span class="n">data3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span><span class="p">(</span><span class="n">name3</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Just remember to not use a member before it is declared, otherwise the compiler will error. Also note how <code class="docutils literal notranslate"><span class="pre">this.</span></code> is not prefixed in front of <code class="docutils literal notranslate"><span class="pre">data2</span></code> and <code class="docutils literal notranslate"><span class="pre">data3</span></code> since there are not parameter names that can confuse the compiler on which variable is being used.</p>
</section>
<section id="copy-constructors">
<h3>Copy Constructors<a class="headerlink" href="#copy-constructors" title="Link to this heading"></a></h3>
<p>Suppose we have the below code:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MyData</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyData</span><span class="p">(</span><span class="s">&quot;name1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name3&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="w">    </span><span class="n">MyData</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we make a copy of the data. Copy constructors will always exist by default for structs, unless:</p>
<ol class="arabic simple">
<li><p>One of the members of the struct does not have a copy constructor.</p></li>
<li><p>The struct is marked with the <code class="docutils literal notranslate"><span class="pre">NoCopy</span></code> attribute.</p></li>
</ol>
<p>The default copy constructor will by default make a copy of each of its members, calling member copy constructors as needed (Ex: The copy constructor of <code class="docutils literal notranslate"><span class="pre">Data</span></code> is called for copying <code class="docutils literal notranslate"><span class="pre">data1</span></code>, <code class="docutils literal notranslate"><span class="pre">data2</span></code>, and <code class="docutils literal notranslate"><span class="pre">data3</span></code>).</p>
<section id="custom-copy-constructor">
<h4>Custom Copy Constructor<a class="headerlink" href="#custom-copy-constructor" title="Link to this heading"></a></h4>
<p>There may be times when you want finer functionality with the copy constructor. This is done by making a constructor with a single parameter of the same type.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="n">This</span><span class="w"> </span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data1</span><span class="p">;</span>
<span class="w">        </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data2</span><span class="p">;</span>
<span class="w">        </span><span class="n">data3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data3</span><span class="p">;</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="move-constructors">
<h3>Move Constructors<a class="headerlink" href="#move-constructors" title="Link to this heading"></a></h3>
<p>Suppose we have the following code:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MyData</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyData</span><span class="p">(</span><span class="s">&quot;name1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name3&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="w">    </span><span class="n">MyData</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we move the data. Move constructors will always exist by default for structs, unless:</p>
<ol class="arabic simple">
<li><p>One of the members of the struct does not have a move constructor.</p></li>
<li><p>The struct is marked with the <code class="docutils literal notranslate"><span class="pre">NoMove</span></code> attribute.</p></li>
</ol>
<p>The default move constructor will by default move each of its members, calling member copy constructors as needed (Ex: The move constructor of <code class="docutils literal notranslate"><span class="pre">Data</span></code> is called for move <code class="docutils literal notranslate"><span class="pre">data1</span></code>, <code class="docutils literal notranslate"><span class="pre">data2</span></code>, and <code class="docutils literal notranslate"><span class="pre">data3</span></code>).</p>
<section id="custom-move-constructor">
<h4>Custom Move Constructor<a class="headerlink" href="#custom-move-constructor" title="Link to this heading"></a></h4>
<p>There may be times when you want finer functionality with the move constructor. This is done by making a constructor with a single parameter of the same type, marked with <code class="docutils literal notranslate"><span class="pre">move</span></code>.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">This</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">data1</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data1</span><span class="p">;</span>
<span class="w">        </span><span class="n">data2</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data2</span><span class="p">;</span>
<span class="w">        </span><span class="n">data3</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">data3</span><span class="p">;</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="empty-constructor">
<h3>Empty Constructor<a class="headerlink" href="#empty-constructor" title="Link to this heading"></a></h3>
<p>The empty constructor exists by default and is deleted if any constructor for the struct is defined. Of course you are free to define your own empty constructors as you like. But in the case an empty constructor exists, the syntax is valid:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="p">);</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>All structs on the stack must be initialized, and so <code class="docutils literal notranslate"><span class="pre">color</span></code> has all its members with their default values.</p>
</section>
</section>
<section id="default-values">
<h2>Default Values<a class="headerlink" href="#default-values" title="Link to this heading"></a></h2>
<p>Sometimes you don’t want to have to define items in the constructor, as it is easier to have the defaults present in the struct itself. This can be done in the struct declaration:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">Data</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data3</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">myStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hi&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">data1</span></code> and <code class="docutils literal notranslate"><span class="pre">data3</span></code> are of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> and do not have a default/parameter-less constructor, and so will need to be constructed in a constructor for <code class="docutils literal notranslate"><span class="pre">MyData</span></code>.</p>
</section>
<section id="destructors">
<h2>Destructors<a class="headerlink" href="#destructors" title="Link to this heading"></a></h2>
<p>If a struct contains resources that are initialized, you may want them to be destroyed when the struct is freed. This can be done via deconstructors:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="w"> </span><span class="n">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">~</span><span class="n">This</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Data deleted.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">MyData</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyData</span><span class="p">(</span><span class="s">&quot;name1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name3&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Hi!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Data deleted.
Hi!
</pre></div>
</div>
<p>Deconstructors take no parameters and return nothing. They are not marked with <code class="docutils literal notranslate"><span class="pre">fn</span></code>, as they are not functions either. There may only be one deconstructor defined per struct.</p>
</section>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Link to this heading"></a></h2>
<p>It is possible to give structures attributes. Attributes are used either by the programmer or the compiler to mark special properties of structures. An example usage of attributes is below:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">NoCopy</span><span class="p">]</span>
<span class="p">[</span><span class="n">PaddingAlignment</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
<span class="p">[</span><span class="n">AssertMemberSize</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)]</span>
<span class="k">struct</span> <span class="nc">MyData</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">Data</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Data</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">Data</span><span class="w"> </span><span class="n">data3</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">myStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hi&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An attribute with no parameters has no need for parenthesis, though attributes with parameters have them passed as if calling a function, arguments separated by commas.</p>
<section id="attribute-list">
<h3>Attribute List<a class="headerlink" href="#attribute-list" title="Link to this heading"></a></h3>
<p>Below is a table of attributes for structs:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Args</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AssertMemberSize</p></td>
<td><p>member, bytes</p></td>
<td><p>Ensure member <code class="docutils literal notranslate"><span class="pre">member</span></code> is <code class="docutils literal notranslate"><span class="pre">bytes</span></code> bytes in size.</p></td>
</tr>
<tr class="row-odd"><td><p>AssertSize</p></td>
<td><p>bytes</p></td>
<td><p>Ensure the entire struct is <code class="docutils literal notranslate"><span class="pre">bytes</span></code> bytes in size.</p></td>
</tr>
<tr class="row-even"><td><p>NoCopy</p></td>
<td><p>-</p></td>
<td><p>Prevent copying of the struct.</p></td>
</tr>
<tr class="row-odd"><td><p>NoMove</p></td>
<td><p>-</p></td>
<td><p>Prevent moving of the struct.</p></td>
</tr>
<tr class="row-even"><td><p>PaddingAlignment</p></td>
<td><p>bytes</p></td>
<td><p>Ensure that each member of the struct is aligned to <code class="docutils literal notranslate"><span class="pre">bytes</span></code> bytes.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Link to this heading"></a></h2>
<p>Getters and setters can be annoying to implement, though Asylum does its best to make them easier to work with. Those familiar with C# may recall similar looking code:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num1</span><span class="p">;</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">get</span><span class="p">;</span><span class="w"> </span><span class="n">pri</span><span class="w"> </span><span class="n">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="n">get</span><span class="p">;</span><span class="w"> </span><span class="n">pro</span><span class="w"> </span><span class="n">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num5</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num6</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num5</span><span class="p">;</span>
<span class="w">        </span><span class="n">pri</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">num3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num7</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">num5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">num8</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get</span><span class="p">;</span>
<span class="w">        </span><span class="n">set</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above showcases different ways properties may be utilized. The above code may be confusing, hopefully these rules clear things up:</p>
<ol class="arabic simple">
<li><p>Getters or setters for properties each have their own access modifiers. They do not have to match. These getters and setter access modifiers override what the member variable is declared as.</p></li>
<li><p>If an access modifier is not set for a getter or setter, it will default to the variable member’s access modifier.</p></li>
<li><p>The scope of a getter or setter’s access modifier is not allowed to be narrower in scope than the member’s access modifier.</p></li>
<li><p>A lamba operator <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> can be used to immediately return a value for the get property. It is not possible to assign variables with this a value.</p></li>
<li><p>The lambda operator <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> is allowed to be used for getters or setters in particular, or use curly brackets to note that it is a function, and you can call functions implemented by the struct in it. Note that <code class="docutils literal notranslate"><span class="pre">_</span></code> represents the value you give in the set function. The type of <code class="docutils literal notranslate"><span class="pre">_</span></code> will be the same type as the member variable.</p></li>
</ol>
</section>
<section id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Link to this heading"></a></h2>
<p>In the variables section, you learned about various operators that can be applied to variables. However, most of the operators are not implemented by default. Below is how operator overloading works for an example vector structure:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">Vec3</span><span class="p">(</span><span class="n">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span>: <span class="nc">x</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// TODO: IMPLEMENTATION SCOPE???</span>
<span class="k">impl</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">op</span><span class="p">(</span><span class="n">Vec3</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Vec3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Vec3</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">Sub</span><span class="o">&lt;</span><span class="n">Vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">op</span><span class="p">(</span><span class="n">Vec3</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Vec3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Vec3</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">Neg</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Vec3</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">op</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Vec3</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Vec3</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Inheritance is discussed further in the next section. For now, know that structs are allowed to implement interfaces as they see fit, and such implementations get their own implementation blocks. Asylum has a built-in namespace in its EASL (Embedded Asylum Standard Library) named <code class="docutils literal notranslate"><span class="pre">op</span></code> that contains interfaces for all overloadable operators. The function to implement the operator is always called <code class="docutils literal notranslate"><span class="pre">op</span></code>. For the <code class="docutils literal notranslate"><span class="pre">Add</span></code> and <code class="docutils literal notranslate"><span class="pre">Sub</span></code> implementations above, the <code class="docutils literal notranslate"><span class="pre">&lt;Vec3&gt;</span></code> indicates that we are “adding with” a <code class="docutils literal notranslate"><span class="pre">Vec3</span></code>.</p>
<section id="overloadable-operators">
<h3>Overloadable Operators<a class="headerlink" href="#overloadable-operators" title="Link to this heading"></a></h3>
<p>See <a class="reference internal" href="#/walkthrough/variables.html#general-operators"><span class="xref myst">Operators</span></a> for information about each operator’s “intended usage”. Below lists overloadable operators:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Type Args</p></th>
<th class="head"><p>Function Args</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p>Add</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> + <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Sub</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> - <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>*</p></td>
<td><p>Mul</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> * <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>/</p></td>
<td><p>Div</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> / <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>%</p></td>
<td><p>Mod</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> % <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>**</p></td>
<td><p>Exp</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> ** <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>..</p></td>
<td><p>Range</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> .. <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>..=</p></td>
<td><p>RangeEq</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> ..= <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>&amp;</p></td>
<td><p>BitAnd</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>|</p></td>
<td><p>BitOr</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> | <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>BitXor</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> ^ <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>~</p></td>
<td><p>BitNot</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>~<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-even"><td><p>&lt;&lt;</p></td>
<td><p>Lshift</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &lt;&lt; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>&gt;&gt;</p></td>
<td><p>Rshift</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &gt;&gt; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>+</p></td>
<td><p>Pos</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>+<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Neg</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>-<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-even"><td><p>++</p></td>
<td><p>Inc</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>++<code class="docutils literal notranslate"><span class="pre">This</span></code>; <code class="docutils literal notranslate"><span class="pre">This</span></code>++</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">--</span></code></p></td>
<td><p>Dec</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">--This</span></code>; <code class="docutils literal notranslate"><span class="pre">This--</span></code></p></td>
</tr>
<tr class="row-even"><td><p>^</p></td>
<td><p>FromLast</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>^<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>*</p></td>
<td><p>Dereference</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>*<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-even"><td><p>!</p></td>
<td><p>Not</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>!<code class="docutils literal notranslate"><span class="pre">This</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>==</p></td>
<td><p>Eq</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> == <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>!=</p></td>
<td><p>Neq</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> != <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>&gt;</p></td>
<td><p>Gt</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>&lt;</p></td>
<td><p>Lt</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>&gt;=</p></td>
<td><p>Ge</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &gt;= <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>&lt;=</p></td>
<td><p>Le</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &lt;= <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>&lt;=&gt;</p></td>
<td><p>Cmp</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code> &lt;=&gt; <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
</tr>
<tr class="row-even"><td><p>[]</p></td>
<td><p>Index</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span></code> other</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">This</span></code>[<code class="docutils literal notranslate"><span class="pre">T</span></code>]</p></td>
</tr>
</tbody>
</table>
<p>TODO: ASSIGNMENTS!!!</p>
</section>
<section id="dereference-operator-overloading">
<h3>Dereference Operator Overloading<a class="headerlink" href="#dereference-operator-overloading" title="Link to this heading"></a></h3>
<p>In Asylum, implementing the dereference operator has a special effect in which the dot <code class="docutils literal notranslate"><span class="pre">.</span></code> operator now operates on the dereferenced item rather than the struct implementing it. In order to access members implementing the struct, the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator must be used instead:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">MyWrapper</span><span class="w"> </span><span class="p">{</span>
<span class="k">pub</span>:
    <span class="nc">Data</span><span class="w"> </span><span class="n">wrapped</span><span class="p">;</span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">Dereference</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyWrapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">op</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">ref</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">wrapped</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MyWrapper</span><span class="w"> </span><span class="n">mw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyWrapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">mw</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">mw</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="o">@</span><span class="n">mw</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span>
</pre></div>
</div>
<p>As you can see above, when we use the <code class="docutils literal notranslate"><span class="pre">.</span></code> operator on <code class="docutils literal notranslate"><span class="pre">mw</span></code> it no longer accesses <code class="docutils literal notranslate"><span class="pre">MyWrapper</span></code>, but rather <code class="docutils literal notranslate"><span class="pre">Data</span></code>. In order to access what is truly in <code class="docutils literal notranslate"><span class="pre">mw</span></code>, you have to treat it as an assignable reference using the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator. The reason for this is to allow the ability of implementing custom wrapper types. This is discussed later in the section on smart references.</p>
</section>
<section id="false-operator-special-notes">
<h3>False Operator Special Notes<a class="headerlink" href="#false-operator-special-notes" title="Link to this heading"></a></h3>
<p>The false <code class="docutils literal notranslate"><span class="pre">??</span></code> operator can not be overloaded. This is because it only works on a boolean input. However, pointers for example are implicitly castable if boolean.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">allocIfNull</span><span class="p">(</span><span class="n">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">int</span><span class="o">*</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">??</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">int</span><span class="p">;</span>
</pre></div>
</div>
<p>The above code checks to see if <code class="docutils literal notranslate"><span class="pre">data</span></code> is a null pointer. If it is null, then <code class="docutils literal notranslate"><span class="pre">data</span></code> gets converted to <code class="docutils literal notranslate"><span class="pre">false</span></code> implicitly, which causes a <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">int</span></code> to be returned. Otherwise, <code class="docutils literal notranslate"><span class="pre">data</span></code> is returned as since it has data, it gets converted to <code class="docutils literal notranslate"><span class="pre">true</span></code> implicitly. The operator thus returns data.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">??</span><span class="w"> </span><span class="n">y</span>
<span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="n">x</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span>: <span class="nc">y</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>The above three statements are equivalent.</p>
</section>
</section>
<section id="casts">
<h2>Casts<a class="headerlink" href="#casts" title="Link to this heading"></a></h2>
<p>It is also possible to make your custom type convert to a custom type by implementing a cast. This is done by implementing the type you want to cast to:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="kt">bool</span><span class="p">.</span><span class="n">implicit</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">cast</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code implicitly casts <code class="docutils literal notranslate"><span class="pre">Data</span></code> to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. This means that whenever a value of <code class="docutils literal notranslate"><span class="pre">bool</span></code> type is expected, a value of <code class="docutils literal notranslate"><span class="pre">Data</span></code> type can be given. You can either implement <code class="docutils literal notranslate"><span class="pre">bool.implicit</span></code> or <code class="docutils literal notranslate"><span class="pre">bool.explicit</span></code> but not both (this holds for any type of course, not just <code class="docutils literal notranslate"><span class="pre">bool</span></code>). The difference is that an explicit casts requires you to cast the value yourself (Ex: <code class="docutils literal notranslate"><span class="pre">(bool)myVal</span></code>) when say a <code class="docutils literal notranslate"><span class="pre">bool</span></code> value is expected, where as an implicit cast will allow you to just pass <code class="docutils literal notranslate"><span class="pre">myVal</span></code> and have it be casted automatically.</p>
</section>
<section id="challenges">
<h2>Challenges<a class="headerlink" href="#challenges" title="Link to this heading"></a></h2>
<p>TODO!!!</p>
</section>
<section id="challenge-solutions">
<h2>Challenge Solutions<a class="headerlink" href="#challenge-solutions" title="Link to this heading"></a></h2>
<p>TODO!!!</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="errors.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="inheritance.html" class="btn btn-neutral float-right" title="Inheritance" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Asylum Lang Foundation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>